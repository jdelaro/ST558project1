---
title: "XML Vignette"
author: "Steven Miller and Clayton Ramsey"
date: "June 9, 2019"
output: 
  html_document:
    toc: true
    toc_float: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
# These were recommented from some resources I studied
#library(XML)
library(xml2)
#library(methods)
library(tidyr)
library(plyr)

# https://www.tutorialspoint.com/r/r_xml_files.htm
# https://stackoverflow.com/questions/17198658/how-to-parse-xml-to-r-data-frame
# http://www.informit.com/articles/article.aspx?p=2215520

# This is exploratory work on figuring out XML.
# d <- read_xml("death_rates.xml")
# d_list <- xmlToList(d)
# d_year <- d %>% xml_find_all("//year")
# d_df <- ldply(d_list, data.frame)

```

```{r message=FALSE, warning=FALSE}

library(knitr)
library(ggplot2)
#library(tidyverse)
#library(rmarkdown)
#library(tinytex)
library(dplyr)
library(tidyr)
```  

# Description of XML data
XML stands for extensible markup language. It is a method of formatting and structuring data to be able to easily share the data online. XML data is self describing, which means that the structure of the data as well as the data are embedded in the file. Therefore, an XML file contains the metadata that describes the data in addition to the actual data, which allows for the data to be read in and stored without building the structure of the data.
Source: [TechTarget](https://searchmicroservices.techtarget.com/definition/XML-Extensible-Markup-Language)

XML is a format that can 


# XML packages and functions

This xml file was read in using `xmlToList()` from the `XML` package. This package is located at [CRAN](https://cran.r-project.org/web/packages/XML/index.html). The authors are Duncan Temple Lang and the CRAN Team (including Tomas Kalibera). The package contains a variety of functions with 

>"many approaches for both reading and creating XML (and HTML) documents (including DTDs), both local and accessible via HTTP or FTP. Also offers access to an
'XPath' ``interpreter''."

See <https://cran.r-project.org/web/packages/XML/XML.pdf>

# XML dataset

The CDC uses the [Socrata Open Data API](https://dev.socrata.com/) for requests. However, the API token system was not working when I requested one. Fortunately, there was a way to aquire the file in raw XML format for download.

Our dataset is hosted at the [Centers for Disease Control and Prevention](https://data.cdc.gov/NCHS/NCHS-Death-rates-and-life-expectancy-at-birth/w9j2-ggv5
). There are 1044 observations of 5 variables: Year, Race, Sex, Average Life Expectancy, and Age-Adjusted Death Rate. The following descriptions are from the above website.

**Variables**

* Year: Dates from 1900 to 2015.
* Race: White, Black, or Both Races.
* Sex: Male, Female, or Both Sexes.
* Average Life Expectancy: Not available for the Black population before 1960 because of the way racial categories are formed.
* Age-Adjusted Death Rate: Calculated in a variety of ways based on timeframe. See <https://data.cdc.gov/NCHS/NCHS-Death-rates-and-life-expectancy-at-birth/w9j2-ggv5>.

```{r include=FALSE}
library("XML")

# This produces a "large list" with all the values but in a highly nested structure.
deathRatesDataXMLList <- xmlToList("death_rates.XML")
# This, we can work with.
# For example, this produces the year value from row 2:
#  deathRatesDataXMLList$row[[2]]$year
# This produces the mortality on row 170:
#  deathRatesDataXMLList$row[[170]]$mortality


# One project requirement is to write a custom function. Converting this structure to a data frame would be a reason to do that.

# The input list is l. I'm assuming it's a list formatted just like the one we produced from this XML file. The number of rows to do is n.

XML_list_to_df <- function(l, n=length(l$row)){
  if(!(is.list(l)) | !(is.numeric(n)) | n<1 | n>length(l$row)){
    return(NULL)
  }else{
    d <- data.frame("row" = 1:n) # this will be the output
    x <- character(n)
    # run through the column names...
    for(i in names(l$row[[n]])){
      # grab the values and store them to a vector
      for(j in 1:n){
        #print(as.character(l$row[[j]][i]))
        x[j] <- as.character(l$row[[j]][i])
      }
      # add that to the dataframe with the correct name
#      print(x)
      d[i] <- x
    }
  }
  d %>% tibble::as_tibble() %>% return()
}

# Here is the data frame!
deathRatesDF <- XML_list_to_df(deathRatesDataXMLList)

# deathRatesDataXML <- xmlParse(file = "C:/Users/mille/OneDrive/Documents/ST 558/Death Rates XML.xml")
# Adding the XML to the repo so that we can each access it the same way locally.

# This produces a pointer object.
# deathRatesDataXML <- XML::xmlParse(file = "death_rates.xml")

# This produces a list with pointer objects inside.
# deathRatesDataXMLRead <- read_xml("death_rates.XML")

# This line produces a single factor for each row, with all the data values crammed together.
# deathRatesDataXMLDF <- xmlToDataFrame(deathRatesDataXML) %>% t() %>% data.frame()

# deathRatesData <- tbl_df(deathRatesDataXML)
```

```{r include=FALSE}
# Fixing up the dataframe...
deathRateData <- deathRatesDF %>% dplyr::transmute(Year = as.integer(year),
                                                   Race = as.factor(race),
                                                    Sex = as.factor(sex),
                                             AveLifeExp = as.double(average_life_expectancy),
                                                   Mort = as.double(mortality))

```
```{r include=FALSE}
# Creating new variable: Distance from year mean...
avgLEM <- deathRateData[1:116,] %>% select(Year, AveLifeExp, Mort)

# if(deathRateData$Year == avgLE$Year){
#   deathRateData2 <- deathRateData %>% mutate(DistAvgLifeExp <- (AveLifeExp - avgLE$AveLifeExp))
# }

# yearAvgLifeExp <- deathRateData %>% group_by(Year) %>% summarise(mean(AveLifeExp))
# 
# yearAvgLifeExp <- deathRateData %>% select(Year, Race == "All Races", Sex == "Both Sexes")
# 
# if(deathRateData$Year == yearAvgLifeExp$Year){
#   distFromMean <- deathRateData$AveLifeExp - yearAvgLifeExp$`mean(AveLifeExp)`
# }
# deathRateData2 <- deathRatesDF %>% dplyr::mutate(distFromMean )

```
# Exploratory data analysis

## Tables
Table 1: Cleaned data from the original XML dataset. Values of `NA` were introduced by coercion and remain in this table.

Table 2: Average life expectancy and mortality by race.

Table 3: Average life expectancy and mortality by sex.

Table 4: Average life expectancy and mortality by year.
(I did this to show the averages per year, I think we should include this as table 2)

```{r}
deathRateData %>% DT::datatable()

#Creating a table of just the average life expectancy and mortality rate per year. This is just the row of each year where both sexes and all races are used.
avgLEM <- deathRateData[1:116,] %>% select(Year, AveLifeExp, Mort) %>% arrange(Year)
DT::datatable(avgLEM)

#Rename the variables to do a table join by year
avgLEM <- avgLEM %>% rename(AvgLE = AveLifeExp, AvgMort = Mort)

#Join dataset with avgLEM table to be able to subtract the mean life expectancy for each year
df <- merge(deathRateData, avgLEM, by = "Year")

#Create new variables for distance from mean of each year for each subgroup
df2 <- df %>% mutate(DistFromMeanLE = round((AveLifeExp - AvgLE),1), DistFromMeanMort = round((Mort - AvgMort),1))

#Remove AvgLE and AvgMort variables from datatable and filter the rows to not include the mean observations (observations with Both Sexes and All Races)
AdjustedDeathRateData <- df2 %>% 
              select(Year, Race, Sex, AveLifeExp, Mort, DistFromMeanLE, DistFromMeanMort) %>%
              filter(Race != "All Races" | Sex != "Both Sexes")
DT::datatable(AdjustedDeathRateData, caption = "Life Expectancy and Mortality by Race and Sex ")

# A custom function to integrate rounding with mean for use inside summarise().
RoundedMean <- function(x, k){
  return(round(mean(x, na.rm = TRUE), k))
}

deathRateData %>% group_by(Race) %>% summarise(`Mean Life Expectancy`=RoundedMean(AveLifeExp, 1), `Average Mortality Rate`=RoundedMean(Mort, 1)) %>% kable()

deathRateData %>% group_by(Sex) %>% summarise(`Mean Life Expectancy`=RoundedMean(AveLifeExp, 1), `Average Mortality Rate`=RoundedMean(Mort, 1)) %>% kable()


```


## Graphs

```{r}
g <- ggplot(data = deathRateData, aes(x = Race, y = Mort))
g + geom_boxplot() + geom_jitter(aes(color=Race)) + labs(y = "Mortality Rate per 100,000")


#Line Plot by year 
h <- ggplot(data = avgLEM, aes(x = Year, y = AvgLE))
h + geom_line(color = 'green', lwd=1.2) + labs(title = "Average Life Expectancy by Year")

#Adjust dataset to combine sex and race into one column
CombinedData <- AdjustedDeathRateData %>% unite(col= Race_Sex, Race, Sex, sep = "_")

i <- ggplot(data = CombinedData, aes(x = Year, y = AveLifeExp, group(Race_Sex), fill = Race_Sex, color = Race_Sex))
i + geom_line(lwd = 1.2)
```

